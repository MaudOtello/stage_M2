---
title: "Bayésien"
author: "Maud"
date: "2024-04-11"
output: word_document
---
Ce script à pour objectif de construire un modèle bayésien qui nous permettra de savoir la probabilité d'être dans une espèce sachant son environnement. Il compilera chaque étape de construction du modèle final.

#Environnement de travail
```{r répertoire de travail, echo=FALSE}
setwd("C:/Users/Maud Otello/Documents/cours_r/Stage_M2/script")
```

```{r package}
library(tidyverse) #pour langage tidyvers, ggplot2, dplyr
library(rstan)     #pour faire tourner les fichiers R
library(bayesplot) #pour les graphes posterieurs
library(sf)        #pour la manipulation des couches shapefiles
```

#Mise en place
Pour commencer on va importer les données de la P1, et plus précisément l'année de relevé 2016.
```{r création donné p1}
#arbre > 10 cm de DBH
P1_all <- read.csv("~/cours_r/Stage_M2/ParacouP1AllYears.csv", comment.char="#")
##sélection de l'année 2016
P1_adult <- P1_all %>%
  filter(CensusYear == 2016)
##sélection des colonnes utiles
P1_adult <- P1_adult %>%
  select("idTree","Xutm","Yutm","Family","Genus","Species","Botanist","CensusYear","Circ","CircCorr")

#arbre < 10 cm de DBH
paracou_J <- read.csv("~/cours_r/Stage_M2/2024ParacouJuveniles(v2).csv", sep=";", comment.char="#")

##sélection de la parcelle 1
P1_juvenil <- paracou_J %>%
  filter (Project == "ParacouRegeneration" &
            Plot == 1 &
            CensusYear == 2016 &
            CodeAlive == 1)
##sélection des colonnes utiles
P1_juvenil <- P1_juvenil %>%
  select("idTree","Xutm","Yutm","Family","Genus","Species","Botanist","CensusYear","Circ","CircCorr")

#fusion
P1 <- full_join(P1_juvenil, P1_adult)

#création de la colonne scientificName
P1 <- P1 %>% 
  mutate(scientificName = paste(Genus, Species, sep = " "))

#création de la colonne DBH
P1 <- P1 %>%
  mutate(DBH = 
           if_else(is.na(Circ), CircCorr/pi, Circ/pi))
```

P1 est composé de deux jeux de données différents. Nous travaillons que sur les 25 espèces présentes dans les données juvéniles. Alors nous allons établir un filtre pour finalement n'avoir que celles-ci.
```{r filtre des 25 espèces}
#sélection des espèces d'intérêts
paracou_J <- paracou_J %>%
  mutate(scientificName = paste(Genus, Species, sep = " "))

INRAE <- paracou_J %>%
  filter(Project == "ParacouRegeneration") %>%
  distinct(scientificName) %>%
  pull()

#retrait des espèces sans intérêts
INRAE <- INRAE[!(INRAE %in% c("Symphonia sp.2", "Indet.Indet. Indet.", "Symphonia sp.4", "Symphonia sp.3"))]

#filtre dans P1
P1 <- P1 %>%
  filter(scientificName %in% INRAE)
```
Notre jeu de donnée est ridiculement faible (930 observation tout confondu). **Attention** Nous utilisons deux jeux de données qui ne possèdent pas les mêmes plans expérimentales. En réalité cela nous proviens de l'échantillonnage sur 4m de rayon des individus les plus jeunes. 

Maintenant que nous disposons de notre jeu de donnée **P1**, nous allons identifier les espèces les plus abondantes aux les moins abondantes.  
```{r abondance}
P1 %>%
  group_by(scientificName) %>%
  count(scientificName)%>%
   arrange(desc(n))
```

# Modèle simple (Bernouilli)

La construction du modèle se trouve dans le fichier **m_binomiale**. Nous voudrions avoir Y qui représente 'La probabilité d'obtenir une espèce parmis notre pool d'espèce'. Nous allons réaliser notre modèle sur _Iryanthera hostmannii_ (1) qui a la plus forte abondance et _Dicorynia guianensis_ (0) qui a une plus faible abondance. Le succès de notre modèle correspond à la présence de l'espèce la plus abondante. Notre jeu de donnée initiale sera sous forme de vecteur.

```{r données}
P1_donnee <- P1 %>%
  filter(scientificName == "Dicorynia guianensis" |
           scientificName == "Iryanthera hostmannii")

N = nrow(P1_donnee)
sp = as.integer(P1_donnee$scientificName == "Iryanthera hostmannii") # précise le succès de l'espèce abondante
```
Notre modèle suit une loi binomiale à 1 lancer (Bernouilli).
On fait tourner notre modèle
```{r fit}
fit = stan("m_binomiale.stan", data = list(N = N, y = sp), iter = 1000, chains = 4)

#Convergence du modèle
traceplot(fit)
summary(fit, pars = "p")

#Distribution à posteriori
mcmc_trace(fit, pars = "p")
```
On peut voir grâce à la variance des chaines qu'elles ont bien convergées (1 < Rhat < 1.1). De plus on peut voir que notre p_post a une moyenne autour de 0.76 ce qui semble cohérent avec ce qu'on observe.

# Ajout de la 3e espèces
Maintenant que nous avons réussi à implémenter deux espèces, nous allons essayer d'y ajouter les _Qualea rosea_. Dans la construction de notre modèle dans le fichier **m_multinomiale.stan** nous allons utiliser une matrice de présence/absence des espèces où _s_ est un entier naturel compris entre 1 et 3. Donc on a Y = "La probabilité d'avoir _s_ espèce".
Dans notre matrice une ligne représente une observation. N représente le nombre total d'observation. Ainsi donc nous avons une variable _s_ qui suit une loi binomiale de paramètre n et p. $$ Y_s \text{~} Binomiale (N,p) $$.

Pour la création de notre matrice, nous allons partir d'un data.frame qu'on passera sous un format long. On aura en colonne les espèces et en ligne soit une présence (1), soit une absence (0). Nous considérons la présence de notre espèce _S_ dans le pool d'étude. Il représente pour chaque individu _S_ leur présence 1 et 0 pour toutes les autres espèces (pseudo-absence).

```{r création de la matrice}
#création d'un data.frame avec les espèces d'intérêts
P1_3esp <- P1 %>%
  select(scientificName) %>% 
  filter (scientificName == "Dicorynia guianensis" |
           scientificName == "Iryanthera hostmannii" |
            scientificName == "Qualea rosea") %>%
  mutate(id = row_number()) #nécessité d'un numéro d'observation

#Création de la matrice avec pivot_wider
P1_donnee2 <- P1_3esp %>%
  group_by(id, scientificName) %>% #pour que chaque ligne soit unique
  summarise(presence = ifelse(n() > 0, 1, 0)) %>% # ajout d'un numéro 1 si présence et d'un 0 si pas, n() représente le comptage par ligne 
  pivot_wider(
    names_from = scientificName,
    values_from = presence,
    values_fill = 0) %>%
  ungroup()

#création de la matrice
P1_donnee2 <- P1_donnee2 %>%
  select (- id)%>%
  mutate(across(everything(), as.integer)) %>% #transformation en entier
  as.matrix()
```

Maintenant, dans le fichier **m_multinomial.stan**, pour l'annonce des données nous avons :
```{r données2}
N2 = nrow(P1_donnee2)
S = ncol(P1_donnee2)
y = P1_donnee2
```

Au niveau des paramètres, nous avons _theta_ qui est la probabilité d'appartenir à une espèce du pool. Il sera sous la forme d'un vecteur de longueur _S_ contraints à être positifs et à sommer à 1 (utilisation du _simplex_).
On a $$y[n]$$ qui représente l'observation des espèce _S_ dans notre pool, qui suit une loi multinomiale de paramètre _theta_. Le prior sur theta lui est non informatif et suit une loi uniforme(0,1).**Attention** ce modèle suppose que les probabilités de présence sont indépendantes entre les espèces pour chaque observation. 

Faisons tourner notre modèle.
```{r fit2}
fit2 = stan("m_multinomial.stan", data = list(N = N2, y = y, S = S), iter = 1000, chains = 4)

#Convergence du modèle
traceplot(fit2)
summary(fit2, pars = "theta")

#Distribution à posteriori
mcmc_trace(fit2)
```
Nos chaines convergent (variance des chaines Rhat = 1.0006900 ; 1< Rhat < 1,1). Puis on a 
$$
\theta_{\text{Iryanthera sagotiana}} &= 0.4418041 \\
\theta_{\text{Qualea rosea}} &= 0.4253384 \\
\theta_{\text{Dicorynia guianensis}} &= 0.1728633 \\
$$
# Ajout de la variable environnementale
Alors notre première variable environnementale sera la topographie. Alors nous disposons de la topographie du site. En fonction de la localisation des espèces nous pourrions y associer une variable environnementale. Dans un premier temps on pourrait lui demander ce qui est en plateau et tous les autres pas en plateau. Puis par la suite ajouter de la complexité à cela. 

## Topographie
Nous aimerions construire un modèle qui prend en compte la topographie. Nous disposons des données topographique sous forme de shapefile. Afin d'associer nos données à ce dernier nous allons spatialiser nos observations (rendre nos données en shapefile). Pour l'instant nous allons travailler uniquement sur les 3 espèces précédentes.
```{r importation topo, include = FALSE}
Topo <- st_read("~/cours_r/Stage_M2/Cartographie/Topo4Levels.shp")
#attribution d'un CRS au lieu d'une re-projection
st_crs(Topo) <- st_crs(2972)
```

```{r Sélection des données}
# Création d'un data.frame avec les espèces d'intérêts
P1_spat<- P1 %>%
  select(scientificName, Xutm, Yutm) %>% 
  filter (scientificName == "Dicorynia guianensis" |
           scientificName == "Iryanthera hostmannii" |
            scientificName == "Qualea rosea" &
           !is.na(Xutm)) %>%
  mutate(id = row_number()) %>% # nécessité d'un numéro d'observation
  #spatialisation de nos données
  st_as_sf(coords = c("Xutm", "Yutm"), 
           crs = st_crs(2972)) # st_crs(2972) = RFGR95, c'est la même chose que WGS 84 / UTM zone 22N

# Création de la matrice avec pivot_wider
P1_donnee3 <- P1_spat %>%
  group_by(id, scientificName) %>% # pour que chaque ligne soit unique
  summarise(presence = ifelse(n() > 0, 1, 0)) %>% # ajout d'un numéro 1 si présence et d'un 0 si pas, n() représente le comptage par ligne 
  pivot_wider(
    names_from = scientificName,
    values_from = presence,
    values_fill = 0) %>%
  ungroup()
```

```{r fusion avec la topographie}
# Intersection couche polygone à point (/!\ crs égaux & sens de fusion)
P1_donnee3 <- st_intersection(P1_donnee3, Topo)
```

### Plateau
Le modèle que nous allons construire nous donnerait y = "Probabilité d'appartenir à une espèces de notre pool, lorsque l'on est en plateau". Le succès de notre expérience serait donc d'avoir la présence au plateau **inter** la présence d'une espèce. En d'autre mot nous voudrions la probabilité d'avoir mon espèce sachant que je suis en plateau. La topographie est une variable explicative.

Ainsi donc nous allons créer une matrice avec en colonne le nom des espèces + la présence/absence par observation de la localisation en plateau. La présence sera noté 1 et l'échec 0. Le modèle associé est présent dans le ficiher **m_plateau**. 
```{r fusion avec la topographie}
# Création de la colonne présence/absence en topographie
P1_donnee3 <- P1_donnee3 %>%
  mutate(plateau = if_else(TopoTypeFr == "Plateau", 1, 0))

# Finilisation de la matrice
P1_donnee3 <- P1_donnee3 %>%
  as.data.frame()%>%
  select (- c(id,TopoTypeFr, TopoTypeEn, idTopo, Plot, geometry))%>%
  mutate(across(everything(), as.integer)) %>% #transformation en entier
  as.matrix()
```

Pour la construction de notre modèle **m_plateau.stan** nous utilisons, un nombre total d'observation _N_ qui correspond au nombre de lignes. Puis un nombre d'espèce _s_. La variable topographie correspond à la colonne plateau de notre tableau.

```{r}
N3 = nrow(P1_donnee3)
S3 = ncol(P1_donnee3) - 1 # On retire la colonne plateau
z3 = P1_donnee3[,"plateau"]
y3 = P1_donnee3[, -which(colnames(P1_donnee3) == "plateau")] # On retire la colonne plateau
```
pourquoi j'ai une ligne en plus que ma matrice précédent qu'est-ce qui a changé ?

Alors pour notre model, lorsque nous avons nos données qui suivent une loi Multinomiale de paramètre _alpha_. Puis on utilise un prior sur _alpha_ qui suit une loi de Dirichlet où chaque élément de alpha est un paramètre de "concentration" pour une distribution de probabilité multinomiale avec S catégories.
Nous affichons les résultats uniquement lorsque on se trouve en présence de plateau "z[n] == 1".
```{r model_plateau}
fit3 = stan("m_plateau.stan", data = list(N = N3, S = S3, y = y3, z = z3 ), iter = 1000, chains = 4)

#Convergence du modèle
traceplot(fit3)
summary(fit3, pars = "alpha")

#Distribution à posteriori
# mcmc_trace(fit3, pars = "alpha") // ne veut pas fonctionner
```

